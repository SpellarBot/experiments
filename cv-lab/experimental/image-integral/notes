http://web.missouri.edu/~hantx/ECE8001/notes/lect7/lecture7.pdf
http://www.citr.auckland.ac.nz/~rklette/Books/MK2004/pdf-LectureNotes/08slides.pdf
http://www.openprocessing.org/sketch/100710

euclidian:
[ [ 2**0.5, 1.0, 2**0.5 ]
  [ 1     , 0.0, 1      ]
  [ 2**0.5, 1.0, 2**0.5 ] ]

manhattan:
[ [ 2, 1, 2 ]
  [ 1, 0, 1 ]
  [ 2, 1, 2 ] ]

chessboard:
[ [ 1, 1, 1 ]
  [ 1, 0, 1 ]
  [ 1, 1, 1 ] ]

  // distance transform
  void createDistanceMap(){
 
    // init FG
    img_FG.loadPixels();
    for(int i = 0; i < map_DT.length; i++){
      map_DT[i] = ( img_FG.pixels[i] == col_FG ) ? 0 : Integer.MAX_VALUE;
    }
     
    // setup mask (L,R)
    float M1L = 1;                   float M1R = M1L;
    float M2L = (float)Math.sqrt(2); float M2R = M2L;
    float M3L = 1 ;                  float M3R = M3L;
    float M4L = (float)Math.sqrt(2); float M4R = M4L;
 
    int   px, p1, p2, p3, p4; // indices
    float dx, d1, d2, d3, d4; // distances
     
    int w = img_FG.width;
    int h = img_FG.height;
     
    // L->R pass
    for(int y = 1; y < h; y++){
      for(int x = 1; x < w-1; x++){
        if( map_DT[ px = y*w+x ] > 0 ){
          d1 = M1L + map_DT[ p1 = px-1 ];
          d2 = M2L + map_DT[ p2 = p1-w ];
          d3 = M3L + map_DT[ p3 = p2+1 ];
          d4 = M4L + map_DT[ p4 = p3+1 ];
          dx = min(d1, d2, d3, d4);
          map_DT[px] =dx;
        }
      }
    }
     
    // R->L pass
    for(int y = h-2; y >= 0; y--){
      for(int x = w-2; x >= 1; x--){
        if( map_DT[ px = y*w+x ] > 0 ){
          d1 = M1R + map_DT[ p1 = px+1 ];
          d2 = M2R + map_DT[ p2 = p1+w ];
          d3 = M3R + map_DT[ p3 = p2-1 ];
          d4 = M4R + map_DT[ p4 = p3-1 ];
          dx = min(d1, d2, d3, d4);
          if( map_DT[px] > dx ) map_DT[px] = dx;
        }
      }
    }
     
     
    // find max distance, to create color [0,255];
    float max = 0;
    for(int i = 0; i < map_DT.length; i++){
      if( map_DT[i] < Integer.MAX_VALUE){
        if( max < map_DT[i] ) max = map_DT[i];
      }
    }
    max = 255/max;
     
    // create dt-image
    img_DT.loadPixels();
    for(int i = 0; i < img_DT.pixels.length; i++){
      int g = (int)( map_DT[i] * max);
      img_DT.pixels[i] = 0xFF000000 | g<<16 | g<<8 | g;
    }
    img_DT.updatePixels();
  }

