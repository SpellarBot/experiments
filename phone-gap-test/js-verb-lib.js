var verbs = function () {
    var $self = {};
    $self.allVerbData = {};

    // Compatibilty for IE < 9
    // http://stackoverflow.com/questions/1744310/how-to-fix-array-indexof-in-javascript-for-ie-browsers
    // https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/IndexOf
    if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function(obj, start) {
             for (var i = (start || 0), j = this.length; i < j; i++) {
                 if (this[i] === obj) { return i; }
             }
             return -1;
        }
    }

    /// Make sure obj has all of the default properties required by verbData
    var beSafeObj = function (obj, verbData) {
        if (obj[verbData.hiddenName] !== true) {
            objAugmentProperties(obj, verbData.defaults);
            obj[verbData.hiddenName] = true;
        }
    };

    /// Make sure an array of objects has all of the defuat properties required by verbData
    /// Will traverse nested arrays ie [[obj,obj],obj,[[obj],obj]]
    var beSafeArray = function (obj, verbData) {
        var i;
        if (obj instanceof Array) {
            i = obj.length;
            while (i--) {
                beSafeArray(obj[i], verbData);
            }
        } else {
            beSafeObj(obj, verbData);
        }
    };

    /// Returns the actual 'verb' method 
    /// ie SYS.move(obj) <- '.move' is generated by the below function
    /// We want to use that function to:
    /// (1) Store the object(s) that we'll be modifying
    /// (2) Ensure that object(s) have the required properties
    var createVerbMethod = function (verb) {
        if ($self.allVerbData[verb].config.descendArray) {
            return function (obj) {
                var verbData = $self.allVerbData[verb];
                // If this object hasn't been seen before and the verb required
                // some sort of properties
                if (verbData.config.checkObjects === true) {
                    beSafeArray(obj, verbData);
                }
                $self.allVerbData[verb].object = obj;

                // check the type and return a different set of methods based on the type
                return verbData.modifiers;
            };
        } else {
            return function (obj) {
                var verbData = $self.allVerbData[verb];
                // If this object hasn't been seen before and the verb required
                // some sort of properties
                if (verbData.config.checkObjects === true) {
                    beSafeObj(obj, verbData);
                }
                $self.allVerbData[verb].object = obj;

                // check the type and return a different set of methods based on the type
                return verbData.modifiers;
            };
        }
    };

	var deepCopy = function(thingToCopy){
		var clone, i;
		if( thingToCopy instanceof Array ){
			clone = [];
			i = thingToCopy.length;
			while( i-- ){
				clone.unshift( deepCopy(thingToCopy[i]) );
			}
			return clone;
		}else if( typeof thingToCopy === 'string' ){
			return thingToCopy;
		}else if( thingToCopy instanceof Object ){
			clone = {};
			for( i in thingToCopy ){
				if( thingToCopy.hasOwnProperty(i) ){
					clone[i] = deepCopy(thingToCopy[i]);
				}
			}
			return clone;
		}
		return thingToCopy;
	};

    /// Add properties as specified by augment object to the original object if
    /// they do not exist in the original object.
    var objAugmentProperties = function (original, augment) {
        var prop;
        for (prop in augment) {
            if (augment.hasOwnProperty(prop) && !original.hasOwnProperty(prop)) {
                original[prop] = deepCopy(augment[prop]);
            }
        }
        return original;
    };

    /// Replace/add any properties in/to the original object if override
    /// has them
    var objOverrideProperties = function (original, override) {
        var prop;
        for (prop in override) {
            if (override.hasOwnProperty(prop)) {
                original[prop] = deepCopy(override[prop]);
            }
        }
        return original;
    };

    /// Creates a verb and manages the meta-data
    /// verb is the string to represent the verb (ie 'run')
    /// defaults is an object - it is ALL the defualt properties of an object
    /// that verb can modify
    /// config are special options for configuring the verb
    $self.createVerb = function (verb, defaults, config) {
        // accept multiple 'verbs' ie synonyms
        var verbs = verb.replace(/\s+/g, ' ').split(' ');
        var mainVerb = verbs.shift();
        $self.allVerbData[mainVerb] = {};
        $self.allVerbData[mainVerb].name = mainVerb;
        $self.allVerbData[mainVerb].hiddenName = '_' + mainVerb;
        $self.allVerbData[mainVerb].modifiers = {};
        $self.allVerbData[mainVerb].modifierData = {};
        $self.allVerbData[mainVerb].defaults = {};
        objOverrideProperties($self.allVerbData[mainVerb].defaults, defaults);
        $self.allVerbData[mainVerb].config = {
            checkObjects: true,
            descendArray: false
        };
        objOverrideProperties($self.allVerbData[mainVerb].config, config);
        $self.allVerbData[mainVerb].object = null;
        // create method 
        $self[mainVerb] = createVerbMethod(mainVerb);
        // add synonyms
        var i = verbs.length;
        var iSyn;
        while (i--) {
            iSyn = verbs[i];
            $self.allVerbData[iSyn] = $self.allVerbData[mainVerb];
            $self[iSyn] = $self[mainVerb];
        }
    };

    // Internal function to find all instances of varName.SOMETHING
    // in func.
    var getPropertiesOfVarInFunc = function (varName, func) {
        var code = String(func),
            entityPropRx = new RegExp(varName + '\\.(\\w+)', 'g'),
            propMatches = code.match(entityPropRx),
            i, props = [],
            iProp;
        if (propMatches === null) {
            return [];
        }
        i = propMatches.length
        while (i--) {
            iProp = propMatches[i].split('.')[1];
            // Only add it once
            if (props.indexOf(iProp) === -1) {
                props.push(iProp);
            }
        }
        return props;
    };

    /// Applies a verb modifier to a single object
    var applyMethodToObject = function (obj, method, args) {
        method.apply(obj, args);
    };

    /// Applies a verb modifies to all objects in nested arrays
    var applyMethodToArray = function (obj, method, args) {
        if (obj instanceof Array) {
            var i = obj.length;
            while (i--) {
                var iObj = obj[i];
                applyMethodToArray(iObj, method, args);
            }
        } else {
            applyMethodToObject(obj, method, args);
        }
    };

    /// Create the function that will used in the verb modifier
    /// ie move(myBall).to(10,10) <- creates .to
    var createObjectModifier = function (verb, modifier, action) {
        return function () {
            action.apply($self.allVerbData[verb].object, arguments);
            return $self.allVerbData[verb].modifiers;
        };
        //$self.allVerbData[verb].modifierData[modifier] 
    };

    /// Creates the array version of the above
    /// ie move([myBall,balls]).to(10,10) <- creates .to
    var createArrayModifier = function (verb, modifier, action) {
        return function () {
            applyMethodToArray($self.allVerbData[verb].object, action, arguments);
            return $self.allVerbData[verb].modifiers;
        };
    };

    /// Used to create the modifer
    $self.addModifier = function (verb, modifier, action) {
        var mod = {}, i;
	var modifiers = modifier.replace(/\s+/g, ' ').split(' ');
        var mainModifier = modifiers.shift();
        mod.name = mainModifier;
        mod.action = action;
        // find the properties:
        mod.props = getPropertiesOfVarInFunc('this', action);
        // check properties with defaults:
        var i = mod.props.length;
	if($self.allVerbData[verb].config.checkObjects){
        while (i--) {
            if (!$self.allVerbData[verb].defaults.hasOwnProperty(mod.props[i])) {
                console.info('Property "'+ mod.props[i] +'" has no specified default value in "' + verb + ' ' + mainModifier + '".');
            }
        }
	}
        $self.allVerbData[verb].modifierData[mainModifier] = mod;
        if ($self.allVerbData[verb].config.descendArray) {
            $self.allVerbData[verb].modifiers[mainModifier] = createArrayModifier(verb, mainModifier, action);
        } else {
            $self.allVerbData[verb].modifiers[mainModifier] = createObjectModifier(verb, mainModifier, action);
        }
        // add synonyms
        var i = modifiers.length;
        var iSyn;
        while (i--) {
            iSyn = modifiers[i];
            $self.allVerbData[verb].modifiers[iSyn] = $self.allVerbData[verb].modifiers[mainModifier];
        }
    };

    $self.addSynonyms = function (oldVerb, newVerbs) {
        var syns = newVerbs.replace(/\s+/g, ' ').split(' '),
            iSyn,
            i = syns.length;
        while (i--) {
            iSyn = syns[i];
            $self.allVerbData[iSyn] = $self.allVerbData[oldVerb];
            $self[iSyn] = $self[oldVerb];
        }
    };

    $self.addHelper = function(name,helper){
        $self[name] = helper;
    };

    return $self;
};


var GV = verbs();
var objDefaults = {
	cx: 0,
	cy: 0,
	r: 16,
	xSize: 32,
	xHalf: 16,
	ySize: 32,
	yHalf: 16,
	xMin: -16,
	xMax: 16,
	yMin: -16,
	yMax: 16,
	speed: 0,
	xSpeed: 0,
	ySpeed: 0,
	rDirection: 0,
	dDirection: 0,
	node: null,
	nodeStyleUnit: "%",
	nodeBgColor: "#000"
};
var verbConfig = {descendArray:true};

// Sizing
GV.createVerb('size resize scale',objDefaults,verbConfig);
GV.addHelper('aabbFromCenter',function(obj){
	obj.xMin = obj.cx - obj.xHalf;
	obj.xMax = obj.cx + obj.xHalf;
	obj.yMin = obj.cy - obj.yHalf;
	obj.yMax = obj.cy + obj.yHalf;
});
GV.addModifier('size','to',function(width,height,radius){
	this.xSize = width;
	this.xHalf = width * 0.5;
	this.ySize = height;
	this.yHalf = height * 0.5;
	this.r = radius;
	GV.aabbFromCenter(this);
});
GV.addModifier('size','asBox toBox toRect asRect',function(width,height){
	this.xSize = width;
	this.xHalf = width * 0.5;
	this.ySize = height;
	this.yHalf = height * 0.5;
	this.r = (this.xHalf + this.yHalf) * 0.5;
	GV.aabbFromCenter(this);
});
GV.addModifier('size','asCircle toCircle',function(radius){
	this.r = radius;
	this.xSize = radius * 2;
	this.xHalf = radius;
	this.ySize = radius * 2;
	this.yHalf = radius;
	GV.aabbFromCenter(this);
});
GV.addModifier('scale','by',function(xScale,yScale){
	this.r *= (xScale+yScale)*0.5;
	this.xSize *= xScale;
	this.xHalf *= xScale;
	this.ySize *= yScale;
	this.yHalf *= yScale;
	GV.aabbFromCenter(this);
});
GV.addModifier('scale','toMax within',function(xMax,yMax){
	if( this.xSize > xMax ){ this.xSize = xMax; this.xHalf = xMax*0.5; }
	if( this.ySize > yMax ){ this.ySize = yMax; this.yHalf = yMax*0.5; }
	GV.aabbFromCenter(this);
});
GV.addModifier('scale','toMin',function(xMin,yMin){
	if( this.xSize < xMin ){ this.xSize = xMin; this.xHalf = xMin*0.5; }
	if( this.ySize < yMin ){ this.ySize = yMin; this.yHalf = yMin*0.5; }
	GV.aabbFromCenter(this);
});

// Moving
GV.createVerb('move push shift',objDefaults,verbConfig);
GV.addModifier('move','to',function(x,y){
	this.cx = x;
	this.cy = y;
	GV.aabbFromCenter(this);
});
GV.addModifier('move','by',function(dx,dy){
	this.cx += dx;
	this.cy += dy;
	GV.aabbFromCenter(this);
});
GV.addModifier('move','bySpeed',function(scale){
	this.cx += this.xSpeed*scale;
	this.cy += this.ySpeed*scale;
	GV.aabbFromCenter(this);
});
GV.addHelper('moveTowardGoal',function(value,goal,delta){
// Add (delta or less) to value so that it is as close as possible to goal
	if( value > goal ){
		if( value - delta < goal ){
			return goal;
		}else{
			return value - delta;
		}
	}
	if( value < goal ){
		if( value + delta > goal ){
			return goal;
		}else{
			return value + delta;
		}
	}
	return goal;
});
GV.addModifier('move','towardX',function(xGoal,xSpeed){
	this.cx = GV.moveTowardGoal(this.cx,xGoal,xSpeed);
	GV.aabbFromCenter(this);
});
GV.addModifier('move','towardRight',function(xGoal,xSpeed){
	// Don't move right if we passed the goal already
	if( this.cx >= xGoal ){ return; }
	this.cx = GV.moveTowardGoal(this.cx,xGoal,xSpeed);
	GV.aabbFromCenter(this);
});
GV.addModifier('move','towardLeft',function(xGoal,xSpeed){
	// Don't move left if we passed the goal already
	if( this.cx <= xGoal ){ return; }
	this.cx = GV.moveTowardGoal(this.cx,xGoal,xSpeed);
	GV.aabbFromCenter(this);
});
GV.addModifier('move','towardY',function(yGoal,ySpeed){
	this.cy = GV.moveTowardGoal(this.cy,yGoal,ySpeed);
	GV.aabbFromCenter(this);
});
GV.addModifier('move','towardTop',function(yGoal,ySpeed){
	// Don't move up if we passed the goal already
	if( this.cy <= yGoal ){ return; }
	this.cy = GV.moveTowardGoal(this.cy,yGoal,ySpeed);
	GV.aabbFromCenter(this);
});
GV.addModifier('move','towardBottom',function(yGoal,ySpeed){
	// Don't move up if we passed the goal already
	if( this.cy >= yGoal ){ return; }
	this.cy = GV.moveTowardGoal(this.cy,yGoal,ySpeed);
	GV.aabbFromCenter(this);
});
GV.addModifier('move','toward',function(xGoal,yGoal,xSpeed,ySpeed){
	this.cx = GV.moveTowardGoal(this.cx,xGoal,xSpeed);
	this.cy = GV.moveTowardGoal(this.cy,yGoal,ySpeed);
	GV.aabbFromCenter(this);
});
// WARNING for inside functions - check argument order with test (I changed the order from the old version)
GV.addHelper('computeAmountOutside',function(min,num,max){
	if( num < min ){ return num - min; }
	if( num > max ){ return num - max; }
	return 0;
});
GV.addModifier('move','insideX',function(xMin,xMax){
	var distToEdgeRight = GV.computeAmountOutside(xMin,this.xMax,xMax),
	    distToEdgeLeft = GV.computeAmountOutside(xMin,this.xMin,xMax);
	if( Math.abs( distToEdgeRight ) > Math.abs( distToEdgeLeft ) ){
		this.cx -= distToEdgeRight;
	}else{
		this.cx -= distToEdgeLeft;
	}
	GV.aabbFromCenter(this);
});
GV.addModifier('move','insideY',function(yMin,yMax){
	var distToEdgeBottom = GV.computeAmountOutside(yMin,this.yMax,yMax),
	    distToEdgeTop = GV.computeAmountOutside(yMin,this.yMin,yMax);
	if( Math.abs( distToEdgeTop ) > Math.abs( distToEdgeBottom ) ){
		this.cy -= distToEdgeTop;
	}else{
		this.cy -= distToEdgeBottom;
	}
	GV.aabbFromCenter(this);
});
GV.addModifier('move','inside',function(xMin,yMin,xMax,yMax){
	var distToEdgeRight = GV.computeAmountOutside(xMin,this.xMax,xMax),
	    distToEdgeLeft = GV.computeAmountOutside(xMin,this.xMin,xMax),
	    distToEdgeBottom = GV.computeAmountOutside(yMin,this.yMax,yMax),
	    distToEdgeTop = GV.computeAmountOutside(yMin,this.yMin,yMax);
	if( Math.abs( distToEdgeRight ) > Math.abs( distToEdgeLeft ) ){
		this.cx -= distToEdgeRight;
	}else{
		this.cx -= distToEdgeLeft;
	}
	if( Math.abs( distToEdgeTop ) > Math.abs( distToEdgeBottom ) ){
		this.cy -= distToEdgeTop;
	}else{
		this.cy -= distToEdgeBottom;
	}
	GV.aabbFromCenter(this);
});
GV.addModifier('move','wrapX',function(xMin,xMax){
	var xWrapSize = xMax - xMin;
	if( this.cx > xMax ){ this.cx = xMin + Math.abs(this.cx % xWrapSize); }else
	if( this.cx < xMin ){ this.cx = xMax - Math.abs(this.cx % xWrapSize); }
	GV.aabbFromCenter(this);
});
GV.addModifier('move','wrapY',function(yMin,yMax){
	var yWrapSize = yMax - yMin;
	if( this.cy > yMax ){ this.cy = yMin + Math.abs(this.cy % yWrapSize); }else
	if( this.cy < yMin ){ this.cy = yMax - Math.abs(this.cy % yWrapSize); }
	GV.aabbFromCenter(this);
});
GV.addModifier('move','wrap',function(xMin,yMin,xMax,yMax){
	// BUG: Go any distance larger than a multiple of (xMax - xMin) past the edges
	// How far the right edge of the object is past the left edge of the 'world'
	/*
	var distPastEdgeLeft = GV.computeAmountOutside(xMin,this.xMax,xMax),
	    distPastEdgeRight = GV.computeAmountOutside(xMin,this.xMin,xMax);
	if( distPastEdgeLeft < 0 ){
		this.cx = xMax + distPastEdgeLeft + this.xHalf;
	}else if( distPastEdgeRight > 0 ){
		this.cx = xMin + distPastEdgeRight - this.xHalf;
	}
	var distPastEdgeTop = GV.computeAmountOutside(yMin,this.yMax,yMax),
	    distPastEdgeBottom = GV.computeAmountOutside(yMin,this.yMin,yMax);
	if( distPastEdgeTop < 0 ){
		this.cy = yMax + distPastEdgeTop + this.yHalf;
	}
	if( distPastEdgeBottom > 0 ){
		this.cy = yMin + distPastEdgeBottom - this.yHalf;
	}
	*/
	var xWrapSize = xMax - xMin;
	if( this.cx > xMax ){ this.cx = xMin + Math.abs(this.cx % xWrapSize); }else
	if( this.cx < xMin ){ this.cx = xMax - Math.abs(this.cx % xWrapSize); }
	var yWrapSize = yMax - yMin;
	if( this.cy > yMax ){ this.cy = yMin + Math.abs(this.cy % yWrapSize); }else
	if( this.cy < yMin ){ this.cy = yMax - Math.abs(this.cy % yWrapSize); }
	GV.aabbFromCenter(this);
});
GV.addHelper('moveCircleOffCircle',function(c1,c2){
	if( c1 === c2 ){ return; }
	var dx = c1.cx - c2.cx,
	    dy = c1.cy - c2.cy,
	    r = c1.r + c2.r,
	    dist2 = dx*dx + dy*dy;
	if( dist2 > r*r ){ return; }
	// The distance and overlap between the 2 circles
	var dist = Math.sqrt(dist2),
	    over = 2*(r - dist);
	// Move c1 'back' (ie negative speed) to a free/just touching position
	var nx = c1.xSpeed / c1.speed,
	    ny = c1.ySpeed / c1.speed;
	c1.cx -= over * nx;
	c1.cy -= over * ny;
	// return false;
});
GV.addHelper('moveCircleOffCircleArray',function(c1,c2){
	var i;
	if( c2 instanceof Array ){
		i = c2.length;
		while( i-- ){
			if( GV.moveCircleOffCircleArray(c1,c2[i]) === false ){
				return false;
			}
		}
	}else{
		return GV.moveCircleOffCircle(c1,c2);
	}
});
GV.addModifier('move','outsideCircle',function(circles){
	GV.moveCircleOffCircleArray(this,circles);
});

// Accelerating
GV.createVerb('accelerate',objDefaults,verbConfig);
GV.addHelper('degToRad',Math.PI/180);
GV.addHelper('radToDeg',180/Math.PI);
GV.addHelper('computeDirectionFromSpeed',function(obj){
	var rDir = Math.atan2(obj.ySpeed,obj.xSpeed);
	obj.rDirection = rDir;
	obj.dDirection = rDir * GV.radToDeg;
	obj.speed = Math.sqrt(obj.xSpeed * obj.xSpeed + obj.ySpeed * obj.ySpeed);
});
GV.addHelper('computeSpeedComponentsFromDir',function(obj){
	obj.xSpeed = obj.speed * Math.cos( obj.rDirection );
	obj.ySpeed = obj.speed * Math.sin( obj.rDirection );
});
GV.addModifier('accelerate','to',function(xSpeed,ySpeed){
	this.xSpeed = xSpeed;
	this.ySpeed = ySpeed;
	GV.computeDirectionFromSpeed(this);
});
GV.addModifier('accelerate','toDir',function(dDirection,speed){
	this.dDirection = dDirection;
	this.rDirection = dDirection * GV.degToRad;
	this.speed = speed;
	GV.computeSpeedComponentsFromDir(this);
});
GV.addModifier('accelerate','toSpeed',function(speed){
	this.speed = speed;
	GV.computeSpeedComponentsFromDir(this);
});
GV.addModifier('accelerate','by',function(dxSpeed,dySpeed){
	this.xSpeed += dxSpeed;
	this.ySpeed += dySpeed;
	GV.computeDirectionFromSpeed(this);
});
GV.addModifier('accelerate','byDir',function(dDirection,speed){
	var rDirection = dDirection * GV.degToRad,
	    xSpeed = speed * Math.cos(rDirection),
	    ySpeed = speed * Math.sin(rDirection);
	this.xSpeed += xSpeed;
	this.ySpeed += ySpeed;
	GV.computeDirectionFromSpeed(this);
});
GV.addModifier('accelerate','towardDir',function(goalDirection,dDirection,goalSpeed){
	var rDirection = dDirection * GV.degToRad,
	    xSpeed = speed * Math.cos(rDirection),
	    ySpeed = speed * Math.sin(rDirection);
	this.xSpeed += xSpeed;
	this.ySpeed += ySpeed;
	GV.computeDirectionFromSpeed(this);
	this.speed = goalSpeed;
	GV.computeSpeedComponentsFromDir(this);
});
GV.addModifier('accelerate','towardPoint',function(xGoal,yGoal,speed){
	var dx = xGoal - this.cx,
	    dy = yGoal - this.cy,
	    dir = Math.atan2(dy,dx),
	    xSpeed = speed * Math.cos(dir),
	    ySpeed = speed * Math.sin(dir);
	this.xSpeed += xSpeed;
	this.ySpeed += ySpeed;
	GV.computeDirectionFromSpeed(this);
});
GV.addModifier('accelerate','towardX',function(xSpeedGoal,xAcceleration){
	this.xSpeed = GV.moveTowardGoal(xSpeedGoal,xAcceleration);
	GV.computeDirectionFromSpeed(this);
});
GV.addModifier('accelerate','towardY',function(ySpeedGoal,yAcceleration){
	this.ySpeed = GV.moveTowardGoal(ySpeedGoal,yAcceleration);
	GV.computeDirectionFromSpeed(this);
});
GV.addModifier('accelerate','insideSpeed limitSpeed withinSpeed',function(minSpeed,maxSpeed){
	if( this.speed < minSpeed ){
		this.speed = minSpeed;
		GV.computeSpeedComponentsFromDir(this);
	}
	if( this.speed > maxSpeed ){
		this.speed = maxSpeed;
		GV.computeSpeedComponentsFromDir(this);
	}
});
GV.createVerb('turn',objDefaults,verbConfig);
GV.addModifier('turn','to',function(dDirection){
	this.dDirection = dDirection;
	this.rDirection = dDirection * GV.degToRad;
	GV.computeSpeedComponentsFromDir(this);
});
GV.addModifier('turn','toRad',function(rDirection){
	this.dDirection = rDirection * GV.radToDeg;
	this.rDirection = rDirection;
	GV.computeSpeedComponentsFromDir(this);
});
GV.createVerb('attract',objDefaults,verbConfig);
GV.addModifier('attract','toPoint',function(xGoal,yGoal,speed){
	var dx = xGoal - this.cx,
	    dy = yGoal - this.cy,
	    d2 = dx*dx + dy*dy,
	    dir = Math.atan2(dy,dx),
	    xSpeed = speed * Math.cos(dir),
	    ySpeed = speed * Math.sin(dir);
	this.xSpeed += xSpeed / d2;
	this.ySpeed += ySpeed / d2;
	GV.computeDirectionFromSpeed(this);
	//GV.computeSpeedComponentsFromDir(this);
});
GV.createVerb('repel',objDefaults,verbConfig);
GV.addModifier('repel','fromPoint',function(xGoal,yGoal,speed){
	var dx = xGoal - this.cx,
	    dy = yGoal - this.cy,
	    d2 = dx*dx + dy*dy,
	    dir = Math.atan2(dy,dx),
	    xSpeed = speed * Math.cos(dir),
	    ySpeed = speed * Math.sin(dir);
	this.xSpeed -= xSpeed / d2;
	this.ySpeed -= ySpeed / d2;
	GV.computeDirectionFromSpeed(this);
	//GV.computeSpeedComponentsFromDir(this);
});


// Bouncing
GV.createVerb('bounce',objDefaults,verbConfig);
GV.addHelper('isOutside',function(min,num,max){
	return (num < min || max < num);
});
GV.addHelper('isInside',function(min,num,max){
	return (min < num && num < max);
});
GV.addModifier('bounce','insideX',function(xMin,xMax){
	if( GV.isOutside(xMin,this.xMin,xMax)
	||  GV.isOutside(xMin,this.xMax,xMax) ){
		this.xSpeed = -this.xSpeed;
		GV.aabbFromCenter(this);
	}
});
GV.addModifier('bounce','insideY',function(yMin,yMax){
	if( GV.isOutside(yMin,this.yMin,yMax)
	||  GV.isOutside(yMin,this.yMax,yMax) ){
		this.ySpeed = -this.ySpeed;
		GV.aabbFromCenter(this);
	}
});
GV.addHelper('bounceCircleOffCircle',function(c1,c2){
	if( c1 === c2 ){ return }
	var dx = c1.cx - c2.cx,
	    dy = c1.cy - c2.cy,
	    r = c1.r + c2.r,
	    dist2 = dx*dx + dy*dy;
	if( dist2 > r*r ){ return; }
	// Rr = Ri - 2 N (Ri . N)
	// ReflectedRay = IncidentRay - 2 * SurfaceNormal * ( IncidentRay <dot> SurfaceNormal );
	// rx = ix - 2 * (nx) * (ix*nx + iy*ny);
	// ry = iy - 2 * (ny) * (ix*nx + iy*ny);
	// First
	// The distance and overlap between the 2 circles
	var dist = Math.sqrt(dist2),
	    over = 2*(r - dist);
	// Move c1 'back' (ie negative speed) to a free/just touching position
	//var nxOldSpd = c1.xSpeed / c1.speed,
	//    nyOldSpd = c1.ySpeed / c1.speed;
	var nxOldSpd = dx / dist,
	    nyOldSpd = dy / dist;
	c1.cx += over * nxOldSpd;
	c1.cy += over * nyOldSpd;
	// Compute normalized [+-1] 'surface normal' vector:
	var nx = dx / dist,
	    ny = dy / dist;
	// Compute the normalized 'incident' vector
	var ix = c1.xSpeed / c1.speed,
	    iy = c1.ySpeed / c1.speed;
	// Compute the dot product
	var dot = ix*nx + iy*ny;
	// Compute the normalized resultant vector:
	var xSpeed = ix - 2 * nx * dot,
	    ySpeed = iy - 2 * ny * dot;
	// Move to where it should have 'bounced' after colliding
	// (the amount overlapped is the distance it should be moved)
	c1.cx += over * xSpeed;
	c1.cy += over * ySpeed;
	// Set the speed:
	c1.xSpeed = xSpeed * c1.speed;
	c1.ySpeed = ySpeed * c1.speed;
	GV.computeDirectionFromSpeed(c1);
	GV.aabbFromCenter(c1);
	// return false;
});
GV.addHelper('oldBounceCircleOffCircle',function(c1,c2){
	if( c1 === c2 ){ return }
	var dx = c1.cx - c2.cx,
	    dy = c1.cy - c2.cy,
	    r = c1.r + c2.r,
	    dist2 = dx*dx + dy*dy;
	if( dist2 > r*r ){ return; }
	// Rr = Ri - 2 N (Ri . N)
	// ReflectedRay = IncidentRay - 2 * SurfaceNormal * ( IncidentRay <dot> SurfaceNormal );
	// rx = ix - 2 * (nx) * (ix*nx + iy*ny);
	// ry = iy - 2 * (ny) * (ix*nx + iy*ny);
	// First
	// The distance and overlap between the 2 circles
	var dist = Math.sqrt(dist2);
	// Compute normalized [+-1] 'surface normal' vector:
	var nx = dx / dist,
	    ny = dy / dist;
	// Compute the normalized 'incident' vector
	var ix = c1.xSpeed / c1.speed,
	    iy = c1.ySpeed / c1.speed;
	// Compute the dot product
	var dot = ix*nx + iy*ny;
	// Compute the normalized resultant vector:
	var xSpeed = ix - 2 * nx * dot,
	    ySpeed = iy - 2 * ny * dot;
	// Set the speed:
	c1.xSpeed = xSpeed * c1.speed;
	c1.ySpeed = ySpeed * c1.speed;


	// return false;
});
GV.addHelper('bounceCircleOffCircleArray',function(c1,c2){
	var i;
	if( c2 instanceof Array ){
		i = c2.length;
		while( i-- ){
			if( GV.bounceCircleOffCircleArray(c1,c2[i]) === false ){
				return false;
			}
		}
	}else{
		return GV.bounceCircleOffCircle(c1,c2);
	}
});
GV.addModifier('bounce','outsideCircle',function(circles){
	GV.bounceCircleOffCircleArray(this,circles);
});

var DOM = verbs();
DOM.addHelper('nullNode',(function(){
	var div = document.createElement('div');
	div.style.display = "none";
}()) );
DOM.createVerb('attach insert append',objDefaults,verbConfig);
DOM.addModifier('attach','toNode onNode asChildOf', function(parent){
	var div = document.createElement('div');
	div.style.position = "absolute";
	this.node = div;
	parent.appendChild(this.node);
});
DOM.createVerb('detach remove delete',objDefaults,verbConfig);
DOM.addModifier('detach','fromNode fromParent', function(){
	this.node.parentNode.removeChild( this.node );
	// this.node = DOM.nullNode; // should I just set it to null?
	this.node = null;
});
DOM.createVerb('draw render',objDefaults,verbConfig);
DOM.addModifier('draw','asRect asBox',function(){
	var style = this.node.style;
	var left = parseFloat(style.left);
	var top = parseFloat(style.top);
	var width = parseFloat(style.width);
	var height = parseFloat(style.height);
	var newLeft = this.cx - this.xHalf;
	var newTop = this.cy - this.yHalf;
	if( left !== newLeft ){ style.left = newLeft + this.nodeStyleUnit; }
	if( top !== newTop ){ style.top = newTop + this.nodeStyleUnit; }
	if( width !== this.xSize ){ style.width = this.xSize + this.nodeStyleUnit; }
	if( height !== this.ySize ){ style.height = this.ySize + this.nodeStyleUnit; }
});
DOM.addModifier('draw','inColor withColor colored setBackgroundColor',function(color){
	this.nodeBgColor = color;
	this.node.style.backgroundColor = color;
});
DOM.addModifier('draw','setBorder',function(border){
	this.node.style.border = border;
});
DOM.addModifier('draw','setBorderRadius',function(borderRad){
	this.node.style.borderRadius = borderRad;
});

var UTIL = verbs();
UTIL.createVerb('sort arrange order',{},{descendArray:false,checkObjects:false});
UTIL.addModifier('sort','byDescending byDecreasing',function(property){
	this.sort(function(a,b){
		return b[property] - a[property];
	});
});
UTIL.addModifier('sort','byAscending byIncreasing',function(property){
	this.sort(function(a,b){
		return a[property] - b[property];
	});
});
UTIL.addModifier('sort','byFunction',function(sortFunc){
	this.sort(sortFunc);
});
UTIL.addModifier('sort','randomly',function(){
	var nElements = this.length,
	    nSwaps = 1+Math.floor(nElements / 2),
	    p1, p2, swap;
	while( nSwaps-- ){
		p1 = Math.floor(nElements*Math.random());
		p2 = Math.floor(nElements*Math.random());
		swap = this[p1];
		this[p1] = this[p2];
		this[p2] = swap;
	}
});

UTIL.createVerb('group label',{groups:[]},{descendArray:true,checkObjects:true});
//UTIL.createVerb('group label',{},{descendArray:true,checkObjects:false});
UTIL.addModifier('group','into',function(group){
	// We need everything to have its own array of groups...
	//if( ! this.groups ){ this.groups = []; }
	this.groups.push(group);
	group.push(this);
});
UTIL.addHelper('arrayDeleteIndex',function(anArray,index){
/// Deletes an element from anywhere in the array.
/// anArray: array: The array in which the element will be deleted.
/// index: int: The index of the element that will be deleted.
	// Ignore negative indicies and out of range indicies
	if( index === 0 ){ anArray.shift(); return anArray; }
	if( index < 0 ){ return null; }
	if( index >= anArray.length ){ return null; }
	// Remove the last element
	var lastElement = anArray.pop();
	// If the index wasn't the last element
	if( index < anArray.length ){
		anArray[index] = lastElement;
	}
	return anArray;
});
UTIL.addHelper('removeFromGroup',function(obj,group){
	//console.info(obj);
	//console.info(group);
	// Look through all of the groups that this belongs to
	var i = obj.groups.length;
	while( i-- ){
		// If we found a match
		if( obj.groups[i] === group ){
			// Remove it from that group
			UTIL.arrayDeleteIndex(obj.groups,i);
		}
	}
	// Remove multiple copies if it is there
	// multiple times
	i = group.length;
	while( i-- ){
		if( group[i] === obj ){
			UTIL.arrayDeleteIndex(group,i);
		}
	}
});
UTIL.addModifier('group','outOf from',function(group){
	UTIL.removeFromGroup(this,group);
});
UTIL.addModifier('group','inNone',function(){
	var i = this.groups.length;
	while( i-- ){
		if( this.groups[i] ){
			UTIL.removeFromGroup(this,this.groups[i]);
		}
	}
});

var ITER = verbs();
ITER.createVerb('repeat',{},{descendArray:false,checkObjects:false});
ITER.addModifier('repeat','run times',function(action){
	var i = this;
	while( i-- ){ action( i ); }
});
ITER.createVerb('forEachIn',{},{descendArray:false,checkObjects:false});
ITER.addModifier('forEachIn','run',function(action){
	var nIterations = Math.floor(this.length / 8);
	var nExtra = this.length % 8;
	var i = this.length-1;
	while (nExtra--){
		action(this[i--]);
	}
	while (nIterations--) {
		action(this[i--]);
		action(this[i--]);
		action(this[i--]);
		action(this[i--]);
		action(this[i--]);
		action(this[i--]);
		action(this[i--]);
		action(this[i--]);
	}
});
ITER.addModifier('forEachIn','runQuick',function(action){
	var nIterations = Math.floor(this.length / 8);
	var nExtra = this.length % 8;
	var i = this.length-1;
	while (nExtra--){
		if( action(this[i--]) === false ){ return; }
	}
	while (nIterations--) {
		if( action(this[i--]) === false ){ return; }
		if( action(this[i--]) === false ){ return; }
		if( action(this[i--]) === false ){ return; }
		if( action(this[i--]) === false ){ return; }
		if( action(this[i--]) === false ){ return; }
		if( action(this[i--]) === false ){ return; }
		if( action(this[i--]) === false ){ return; }
		if( action(this[i--]) === false ){ return; }
	}
});
ITER.createVerb('forEachObjIn',{},{descendArray:true,checkObjects:false});
ITER.addModifier('forEachObjIn','run',function(action){
	action(this);
});