/** Highly divisible triangular number
 * The sequence of triangle numbers is generated by adding the natural
 * numbers. So the 7th triangle number would be
 * 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
 * 
 * 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 * 
 * Let us list the factors of the first seven triangle numbers:
 * 
 *      1: 1
 *      3: 1,3
 *      6: 1,2,3,6
 *     10: 1,2,5,10
 *     15: 1,3,5,15
 *     21: 1,3,7,21
 *     28: 1,2,4,7,14,28
 * 
 * We can see that 28 is the first triangle number to have over five
 * divisors.
 * 
 * What is the value of the first triangle number to have over five
 * hundred divisors?
 */

// ------------------------------------------------[ Triangle Numbers ]-

// returns the nth triangle number
function triangle_number(n){
	var sum = 0;
	for( i=0; i<=n; i+=1 ){
		sum += i;
	}
	return sum;
}

// simpler way
function gauss_triangle(n){
	return (n+1)*(n/2);
}

// --------------------------------------------------[ Naive Solution ]-

// return all the factors of n
function list_factors_naive(n){
	var factors = [];
	var i = n+1;
	while( i-- ){
		if( n%i === 0 ){
			factors.push( i );
		}
	}
	return factors;
}

function solve_naive( nDivisors, lowerLimit, upperLimit ){
	var i, number, factors;
	for( i=lowerLimit; i<upperLimit; i+=1 ){
		number = gauss_triangle( i );
		factors = list_factors_naive( number );
		if( factors.length > nDivisors ){
			return number;
		}
	}
	return null;
}

// -------------------------------------------------[ Slightly Better ]-

function list_factors_better(n) {

	// 1 and n are always factors
    var factors = [1,n];

	// There will never be a factor higher than sqrt(n)
    var upperLimit = Math.sqrt(n);

	// Computing
    for( var i = 2; i < upperLimit; i+=1 ){
        if ( n % i === 0 ) {
			upperLimit = n/i;
			factors.push( i );
			factors.push( upperLimit );
        }
    }

	// If the last factor was a perfect square - it was added twice 
	// so remove one
	if( upperLimit*upperLimit === n && factors.length > 2 ){
		factors.pop();
	}

    return factors;
}

// still slow
function solve_better( nDivisors, lowerLimit, upperLimit ){
	var i, number, factors;
	for( i=lowerLimit; i<upperLimit; i+=1 ){
		number = gauss_triangle( i );
		factors = list_factors_better( number );
		if( factors.length > nDivisors ){
			return number;
		}
	}
	return null;
}

// ----------------------------------------------------[ Prime (Fast) ]-

function sieve_of_eratosthenes( upperLimit ){
	// create 2 lists - one of the actual number, the other of prime status
	var numbers = [];
	var isPrime = [];
	var i;
	for( i=0; i<upperLimit; i+=1 ){
		numbers.push( i );
		isPrime.push( true );
	}

	isPrime[0] = false;
	isPrime[1] = false;

	var p = 0;
	while( p < upperLimit ){

		// Find the first number greater than p in the list that is not
		// marked. This is the next prime.
		p += 1;
		while( isPrime[p] === false ){
			p +=1;
		}

		// Starting at p mark every multiple (2p,3p,...) of p in the list
		// but don't include p
		for( i=p*2; i<upperLimit; i+=p ){
			isPrime[ i ] = false;
		}
	}

	// extract the list of primes
	var primes = [];
	for( i=0; i<upperLimit; i+=1 ){
		if( isPrime[i] ){
			primes.push( i );
		}
	}

	return primes;	
}

function prime_factorization( primes, n ){

	var nPrimes = primes.length;
	var factors = [];
	var num = n;

	// Look through all the primes 
	for( var i=0; i<nPrimes; i+=1 ){
		var prime = primes[i];
		
		// When the prime is greater than the square root of n
		// we've search thought every prime that could be a factor
		if( prime*prime > num ){
			break;
		}

		// Compute the number of times (exponent) you can divide by
		// this prime. Factor it out (divide) each time.
		var exponent=0;
		while( num % prime === 0 ){
			exponent += 1;
			num = num/prime;
		}
		if( exponent > 0 ){
			factors.push( [prime, exponent] );
		}

	}

	// Add the remainder (also handles numbers which are prime)
	if( num > 1 ){
		factors.push( [num, 1] );
	}

	return factors;
}

function n_divisors_from_prime_factorization( primeFactors ){
	var nPrimeFactors = primeFactors.length;
	var i,nDiv=1;
	for( i=0; i<nPrimeFactors; i+=1 ){
		nDiv *= primeFactors[i][1]+1;
	}
	return nDiv;
}

function solve_prime( nDivisors, lowerLimit, upperLimit ){
	var primes = sieve_of_eratosthenes(upperLimit);
	var i, number, pFactors;
	for( i=lowerLimit; i<upperLimit; i+=1 ){
		number = gauss_triangle( i );
		pFactors = prime_factorization( primes, number );
		nDiv = n_divisors_from_prime_factorization( pFactors );
		if( nDiv > nDivisors ){
			return number;
		}
	}
	return null;
}

// -----------------------------------------------------------[ Misc. ]-

function from_prime_factorization( primeFactors ){
	var nPrimeFactors = primeFactors.length;
	var i,num=1;
	for( i=0; i<nPrimeFactors; i+=1 ){
		num *= Math.pow(primeFactors[i][0],primeFactors[i][1]);
	}
	return num;
}

function time_it( action ){
	var start = +(new Date());
	action();
	var end = +(new Date());
	console.info( 'Duration: '+ (end-start) +'ms' );	
}

time_it( function(){
	//console.info( solve_naive(500, 0, 100000) );
	//console.info( solve_better(500, 0, 100000) );
	console.info( solve_prime(500, 0, 100000) );
} );

//               Tri-Index Tri-Number N-Divisors  
// The solution: 12375     76576500   576

/** 76576500
 * Congratulations, the answer you gave to problem 12 is correct.
 * 
 * You are the 106838th person to have solved this problem.
 */
